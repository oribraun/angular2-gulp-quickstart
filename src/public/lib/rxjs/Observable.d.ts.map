{"version":3,"names":[],"mappings":"","sources":["rxjs/Observable.d.ts"],"sourcesContent":["import { PartialObserver } from './Observer';\nimport { Operator } from './Operator';\nimport { Subscriber } from './Subscriber';\nimport { Subscription, AnonymousSubscription, TeardownLogic } from './Subscription';\nimport { IfObservable } from './observable/IfObservable';\nimport { ErrorObservable } from './observable/ErrorObservable';\nexport interface Subscribable<T> {\n    subscribe(observerOrNext?: PartialObserver<T> | ((value: T) => void), error?: (error: any) => void, complete?: () => void): AnonymousSubscription;\n}\nexport declare type SubscribableOrPromise<T> = Subscribable<T> | PromiseLike<T>;\nexport declare type ObservableInput<T> = SubscribableOrPromise<T> | ArrayLike<T>;\n/**\n * A representation of any set of values over any amount of time. This the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nexport declare class Observable<T> implements Subscribable<T> {\n    _isScalar: boolean;\n    protected source: Observable<any>;\n    protected operator: Operator<any, T>;\n    /**\n     * @constructor\n     * @param {Function} subscribe the function that is  called when the Observable is\n     * initially subscribed to. This function is given a Subscriber, to which new values\n     * can be `next`ed, or an `error` method can be called to raise an error, or\n     * `complete` can be called to notify of a successful completion.\n     */\n    constructor(subscribe?: <R>(this: Observable<T>, subscriber: Subscriber<R>) => TeardownLogic);\n    /**\n     * Creates a new cold Observable by calling the Observable constructor\n     * @static true\n     * @owner Observable\n     * @method create\n     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n     * @return {Observable} a new cold observable\n     */\n    static create: Function;\n    /**\n     * Creates a new Observable, with this Observable as the source, and the passed\n     * operator defined as the new observable's operator.\n     * @method lift\n     * @param {Operator} operator the operator defining the operation to take on the observable\n     * @return {Observable} a new observable with the Operator applied\n     */\n    lift<R>(operator: Operator<T, R>): Observable<R>;\n    /**\n     * Registers handlers for handling emitted values, error and completions from the observable, and\n     *  executes the observable's subscriber function, which will take action to set up the underlying data stream\n     * @method subscribe\n     * @param {PartialObserver|Function} observerOrNext (optional) either an observer defining all functions to be called,\n     *  or the first of three possible handlers, which is the handler for each value emitted from the observable.\n     * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,\n     *  the error will be thrown as unhandled\n     * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.\n     * @return {ISubscription} a subscription reference to the registered handlers\n     */\n    subscribe(): Subscription;\n    subscribe(observer: PartialObserver<T>): Subscription;\n    subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription;\n    /**\n     * @method forEach\n     * @param {Function} next a handler for each value emitted by the observable\n     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n     * @return {Promise} a promise that either resolves on observable completion or\n     *  rejects with the handled error\n     */\n    forEach(next: (value: T) => void, PromiseCtor?: typeof Promise): Promise<void>;\n    protected _subscribe(subscriber: Subscriber<any>): TeardownLogic;\n    static if: typeof IfObservable.create;\n    static throw: typeof ErrorObservable.create;\n}\n"],"file":"rxjs/Observable.d.ts","sourceRoot":"/source/"}