{"version":3,"names":[],"mappings":"","sources":["rxjs/observable/PromiseObservable.d.ts"],"sourcesContent":["import { Scheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { TeardownLogic } from '../Subscription';\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport declare class PromiseObservable<T> extends Observable<T> {\n    private promise;\n    private scheduler;\n    value: T;\n    /**\n     * Converts a Promise to an Observable.\n     *\n     * <span class=\"informal\">Returns an Observable that just emits the Promise's\n     * resolved value, then completes.</span>\n     *\n     * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an\n     * Observable. If the Promise resolves with a value, the output Observable\n     * emits that resolved value as a `next`, and then completes. If the Promise\n     * is rejected, then the output Observable emits the corresponding Error.\n     *\n     * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>\n     * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));\n     * result.subscribe(x => console.log(x), e => console.error(e));\n     *\n     * @see {@link bindCallback}\n     * @see {@link from}\n     *\n     * @param {Promise<T>} promise The promise to be converted.\n     * @param {Scheduler} [scheduler] An optional Scheduler to use for scheduling\n     * the delivery of the resolved value (or the rejection).\n     * @return {Observable<T>} An Observable which wraps the Promise.\n     * @static true\n     * @name fromPromise\n     * @owner Observable\n     */\n    static create<T>(promise: Promise<T>, scheduler?: Scheduler): Observable<T>;\n    constructor(promise: Promise<T>, scheduler?: Scheduler);\n    protected _subscribe(subscriber: Subscriber<T>): TeardownLogic;\n}\n"],"file":"rxjs/observable/PromiseObservable.d.ts","sourceRoot":"/source/"}