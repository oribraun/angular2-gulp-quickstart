{"version":3,"names":[],"mappings":"","sources":["rxjs/src/operator/windowTime.ts"],"sourcesContent":["import { Scheduler } from '../Scheduler';\nimport { Action } from '../scheduler/Action';\nimport { Subject } from '../Subject';\nimport { Operator } from '../Operator';\nimport { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\n\n/**\n * Branch out the source Observable values as a nested Observable periodically\n * in time.\n *\n * <span class=\"informal\">It's like {@link bufferTime}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowTime.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable starts a new window periodically, as\n * determined by the `windowCreationInterval` argument. It emits each window\n * after a fixed timespan, specified by the `windowTimeSpan` argument. When the\n * source Observable completes or encounters an error, the output Observable\n * emits the current window and propagates the notification from the source\n * Observable. If `windowCreationInterval` is not provided, the output\n * Observable starts a new window when the previous window of duration\n * `windowTimeSpan` completes.\n *\n * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowTime(1000)\n *   .map(win => win.take(2)) // each window has at most 2 emissions\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Every 5 seconds start a window 1 second long, and emit at most 2 click events per window</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowTime(1000, 5000)\n *   .map(win => win.take(2)) // each window has at most 2 emissions\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferTime}\n *\n * @param {number} windowTimeSpan The amount of time to fill each window.\n * @param {number} [windowCreationInterval] The interval at which to start new\n * windows.\n * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine window boundaries.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowTime\n * @owner Observable\n */\nexport function windowTime<T>(this: Observable<T>, windowTimeSpan: number,\n                              windowCreationInterval: number = null,\n                              scheduler: Scheduler = async): Observable<Observable<T>> {\n  return this.lift(new WindowTimeOperator<T>(windowTimeSpan, windowCreationInterval, scheduler));\n}\n\nclass WindowTimeOperator<T> implements Operator<T, Observable<T>> {\n\n  constructor(private windowTimeSpan: number,\n              private windowCreationInterval: number,\n              private scheduler: Scheduler) {\n  }\n\n  call(subscriber: Subscriber<Observable<T>>, source: any): any {\n    return source.subscribe(new WindowTimeSubscriber(\n      subscriber, this.windowTimeSpan, this.windowCreationInterval, this.scheduler\n    ));\n  }\n}\n\ninterface CreationState<T> {\n  windowTimeSpan: number;\n  windowCreationInterval: number;\n  subscriber: WindowTimeSubscriber<T>;\n  scheduler: Scheduler;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass WindowTimeSubscriber<T> extends Subscriber<T> {\n  private windows: Subject<T>[] = [];\n\n  constructor(protected destination: Subscriber<Observable<T>>,\n              private windowTimeSpan: number,\n              private windowCreationInterval: number,\n              private scheduler: Scheduler) {\n    super(destination);\n    if (windowCreationInterval !== null && windowCreationInterval >= 0) {\n      let window = this.openWindow();\n      const closeState = { subscriber: this, window, context: <any>null };\n      const creationState: CreationState<T> = { windowTimeSpan, windowCreationInterval, subscriber: this, scheduler };\n      this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));\n      this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));\n    } else {\n      let window = this.openWindow();\n      const timeSpanOnlyState = { subscriber: this, window, windowTimeSpan };\n      this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));\n    }\n  }\n\n  protected _next(value: T) {\n    const windows = this.windows;\n    const len = windows.length;\n    for (let i = 0; i < len; i++) {\n      const window = windows[i];\n      if (!window.closed) {\n        window.next(value);\n      }\n    }\n  }\n\n  protected _error(err: any) {\n    const windows = this.windows;\n    while (windows.length > 0) {\n      windows.shift().error(err);\n    }\n    this.destination.error(err);\n  }\n\n  protected _complete() {\n    const windows = this.windows;\n    while (windows.length > 0) {\n      const window = windows.shift();\n      if (!window.closed) {\n        window.complete();\n      }\n    }\n    this.destination.complete();\n  }\n\n  openWindow(): Subject<T> {\n    const window = new Subject<T>();\n    this.windows.push(window);\n    const destination = this.destination;\n    destination.next(window);\n    return window;\n  }\n\n  closeWindow(window: Subject<T>) {\n    window.complete();\n    const windows = this.windows;\n    windows.splice(windows.indexOf(window), 1);\n  }\n}\n\ninterface TimeSpanOnlyState<T> {\n  window: Subject<any>;\n  windowTimeSpan: number;\n  subscriber: WindowTimeSubscriber<T>;\n}\n\nfunction dispatchWindowTimeSpanOnly<T>(this: Action<TimeSpanOnlyState<T>>, state: TimeSpanOnlyState<T>) {\n  const { subscriber, windowTimeSpan, window } = state;\n  if (window) {\n    window.complete();\n  }\n  state.window = subscriber.openWindow();\n  this.schedule(state, windowTimeSpan);\n}\n\ninterface Context<T> {\n  action: Action<CreationState<T>>;\n  subscription: Subscription;\n}\n\ninterface DispatchArg<T> {\n  subscriber: WindowTimeSubscriber<T>;\n  window: Subject<T>;\n  context: Context<T>;\n}\n\nfunction dispatchWindowCreation<T>(this: Action<CreationState<T>>, state: CreationState<T>) {\n  let { windowTimeSpan, subscriber, scheduler, windowCreationInterval } = state;\n  let window = subscriber.openWindow();\n  let action = this;\n  let context: Context<T> = { action, subscription: <any>null };\n  const timeSpanState: DispatchArg<T> = { subscriber, window, context };\n  context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);\n  action.add(context.subscription);\n  action.schedule(state, windowCreationInterval);\n}\n\nfunction dispatchWindowClose<T>(arg: DispatchArg<T>) {\n  const { subscriber, window, context } = arg;\n  if (context && context.action && context.subscription) {\n    context.action.remove(context.subscription);\n  }\n  subscriber.closeWindow(window);\n}\n"],"file":"rxjs/src/operator/windowTime.ts","sourceRoot":"/source/"}